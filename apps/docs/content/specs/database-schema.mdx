# Database Schema & Persistence Specification

**Status:** ğŸŸ¢  
**Version:** 1.0  
**Last Updated:** 2026-01-17  
**Owner:** Backend/Database Team  
**Deadline:** Pre-Sprint 0 Implementation  

---

## Overview

This document specifies the complete database schema required for MVP (Sprints 0-4). The schema is designed to:

- Support the [Backend API Contracts](/specs/backend-api-contracts) endpoints
- Enable offline sync and conflict resolution (Sprint 5, if in MVP scope)
- Provide audit trails for accountability (Sprint 7, post-MVP)
- Scale to millions of dispatches across multiple regions
- Support real-time queries for active dispatch listings

**Key Principles:**
- All timestamps are UTC in ISO 8601 format
- Soft deletes (status = "closed") instead of hard deletes, for audit trail
- Immutable event logs (audit_log is append-only)
- Optimistic versioning (version field on mutable records)
- Regional data isolation (all queries filtered by region)

---

## Entity Relationship Diagram (ERD)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   users         â”‚â—„â”€â”€â”€â”€â”€â”¤   dispatches     â”‚
â”‚                 â”‚      â”‚                  â”‚
â”‚ id (PK)         â”‚      â”‚ id (PK)          â”‚
â”‚ email           â”‚      â”‚ region_id (FK)   â”‚
â”‚ role            â”‚      â”‚ submitter_id(FK) â”‚
â”‚ allowed_regions â”‚      â”‚ location_lat     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚ location_lon     â”‚
                         â”‚ status           â”‚
      â–²                  â”‚ urgency          â”‚
      â”‚                  â”‚ version          â”‚
      â”‚                  â”‚ created_at       â”‚
      â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â”‚                         â–²
      â”‚                         â”‚ (1:N)
      â”‚                         â”‚
â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
â”‚  responders (dispatch responders)     â”‚
â”‚                                       â”‚
â”‚ id (PK)                               â”‚
â”‚ dispatch_id (FK) â†’ dispatches.id      â”‚
â”‚ responder_id (FK) â†’ users.id          â”‚
â”‚ status                                â”‚
â”‚ claimed_at                            â”‚
â”‚ updated_at                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  audit_log (immutable, append-only)        â”‚
â”‚                                            â”‚
â”‚ id (PK)                                    â”‚
â”‚ dispatch_id (FK) â†’ dispatches.id           â”‚
â”‚ responder_entry_id (FK) â†’ responders.id    â”‚
â”‚ event_type                                 â”‚
â”‚ actor_id (FK) â†’ users.id                   â”‚
â”‚ before_state (JSON)                        â”‚
â”‚ after_state (JSON)                         â”‚
â”‚ timestamp                                  â”‚
â”‚ region_id                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  notification_queue (transient)  â”‚
â”‚  (for SSE event delivery)        â”‚
â”‚                                  â”‚
â”‚ id (PK)                          â”‚
â”‚ dispatch_id (FK)                 â”‚
â”‚ event_type                       â”‚
â”‚ payload (JSON)                   â”‚
â”‚ created_at                       â”‚
â”‚ delivered_at (nullable)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Table Schemas

### 1. users

Stores user accounts, roles, and region permissions.

```sql
CREATE TABLE users (
  id VARCHAR(32) PRIMARY KEY,          -- Format: "usr_<uuid>"
  email VARCHAR(255) NOT NULL UNIQUE,
  password_hash VARCHAR(255) NOT NULL, -- bcrypt hash
  role ENUM('responder', 'admin', 'viewer') NOT NULL DEFAULT 'responder',
  allowed_regions JSON NOT NULL,       -- Array of region IDs user can access
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  last_login_at TIMESTAMP,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  
  INDEX idx_email (email),
  INDEX idx_role (role),
  INDEX idx_is_active (is_active),
  INDEX idx_created_at (created_at)
);
```

**Fields:**

| Field | Type | Nullable | Rules | Example |
|-------|------|----------|-------|---------|
| `id` | VARCHAR(32) | âŒ | PK; format "usr_(uuid)" | "usr_abc123" |
| `email` | VARCHAR(255) | âŒ | UNIQUE; valid email | "responder@example.com" |
| `password_hash` | VARCHAR(255) | âŒ | bcrypt hash; never store plain text | (bcrypt hash) |
| `role` | ENUM | âŒ | One of: responder, admin, viewer | "responder" |
| `allowed_regions` | JSON | âŒ | Array of region IDs | `["us-east-1", "us-west-2"]` |
| `created_at` | TIMESTAMP | âŒ | UTC; auto-set | "2026-01-17T14:32:00Z" |
| `updated_at` | TIMESTAMP | âŒ | UTC; auto-updated | "2026-01-17T14:50:00Z" |
| `last_login_at` | TIMESTAMP |  | UTC; nullable | "2026-01-17T14:45:00Z" |
| `is_active` | BOOLEAN | âŒ | Default TRUE; soft-delete by FALSE | true |

**Indexes:**
- `idx_email`: Fast lookup by email for login
- `idx_role`: Fast filtering by role
- `idx_is_active`: Fast filtering for active users
- `idx_created_at`: Timeseries queries

---

### 2. dispatches

Core dispatch record. Contains location, description, urgency, and status.

```sql
CREATE TABLE dispatches (
  id VARCHAR(32) PRIMARY KEY,          -- Format: "dsp_<uuid>"
  region_id VARCHAR(32) NOT NULL,      -- Multi-region support
  submitter_id VARCHAR(32) NOT NULL,   -- FK: users.id
  client_id VARCHAR(36),               -- Idempotency key (UUID)
  
  -- Location (required)
  location_lat DECIMAL(8, 6) NOT NULL,
  location_lon DECIMAL(9, 6) NOT NULL,
  location_description VARCHAR(256),   -- "near park", "intersection", etc.
  location_precision ENUM('exact', 'block', 'neighborhood', 'city') 
    NOT NULL DEFAULT 'approximate',
  
  -- Dispatch details (mostly optional)
  description TEXT,                    -- Free text, max 2000 chars
  urgency ENUM('low', 'normal', 'critical') NOT NULL DEFAULT 'normal',
  status ENUM('open', 'acknowledged', 'escalated', 'closed', 'reopened') 
    NOT NULL DEFAULT 'open',
  
  -- Closure details
  closure_reason ENUM(
    'turned_out_okay', 
    'help_arrived', 
    'unable_to_help', 
    'duplicate', 
    'administrative'
  ),
  closed_at TIMESTAMP,
  closed_by_id VARCHAR(32),            -- FK: users.id (who closed it)
  
  -- Versioning & timestamps
  version INT NOT NULL DEFAULT 1,      -- Optimistic locking
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  -- Soft delete (logical, not physical)
  is_deleted BOOLEAN NOT NULL DEFAULT FALSE,
  
  FOREIGN KEY (submitter_id) REFERENCES users(id) ON DELETE RESTRICT,
  FOREIGN KEY (closed_by_id) REFERENCES users(id) ON DELETE SET NULL,
  
  PRIMARY KEY (id),
  UNIQUE KEY unique_client_id (client_id, region_id),  -- Idempotency
  INDEX idx_region (region_id),
  INDEX idx_status (status),
  INDEX idx_urgency (urgency),
  INDEX idx_created_at (created_at),
  INDEX idx_submitter (submitter_id),
  INDEX idx_region_status (region_id, status),  -- For "active in region" queries
  INDEX idx_region_created (region_id, created_at DESC),  -- For pagination
  SPATIAL INDEX spatial_location (location_lat, location_lon)  -- Geo queries (future)
);
```

**Fields:**

| Field | Type | Nullable | Rules | Example |
|-------|------|----------|-------|---------|
| `id` | VARCHAR(32) | âŒ | PK; format "dsp_(uuid)" | "dsp_abc123" |
| `region_id` | VARCHAR(32) | âŒ | FK; multi-region support | "us-east-1" |
| `submitter_id` | VARCHAR(32) | âŒ | FK: users.id | "usr_abc123" |
| `client_id` | VARCHAR(36) |  | Idempotency key; UUID format | "client_xyz789" |
| `location_lat` | DECIMAL(8,6) | âŒ | Range: [-90, 90] | 40.712776 |
| `location_lon` | DECIMAL(9,6) | âŒ | Range: [-180, 180] | -74.005974 |
| `location_description` | VARCHAR(256) |  | Free text | "near park" |
| `location_precision` | ENUM | âŒ | One of: exact, block, neighborhood, city | "block" |
| `description` | TEXT |  | Free text; max 2000 chars | "Person collapsed on sidewalk" |
| `urgency` | ENUM | âŒ | One of: low, normal, critical | "critical" |
| `status` | ENUM | âŒ | One of: open, acknowledged, escalated, closed, reopened | "open" |
| `closure_reason` | ENUM |  | One of: turned_out_okay, help_arrived, etc. | "turned_out_okay" |
| `closed_at` | TIMESTAMP |  | UTC; when status = closed | "2026-01-17T14:55:00Z" |
| `closed_by_id` | VARCHAR(32) |  | FK: users.id (who closed) | "usr_xyz789" |
| `version` | INT | âŒ | Optimistic locking; starts at 1 | 3 |
| `created_at` | TIMESTAMP | âŒ | UTC; auto-set | "2026-01-17T14:32:00Z" |
| `updated_at` | TIMESTAMP | âŒ | UTC; auto-updated | "2026-01-17T14:50:00Z" |
| `is_deleted` | BOOLEAN | âŒ | Soft delete flag; default FALSE | false |

**Status State Machine:**

```
open â”€â”€â†’ acknowledged â”€â”€â†’ escalated â”€â”€â†’ closed
  â–²                                        â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ reopened â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Valid transitions:
- `open` â†’ `acknowledged` (auto on first responder, or manual)
- `acknowledged` â†’ `escalated` (auto after 10 min no response)
- `acknowledged` â†’ `closed` (manual, any responder)
- `escalated` â†’ `closed` (manual, any responder)
- `closed` â†’ `reopened` (manual, within 15 min of closure)
- `reopened` â†’ `acknowledged` or `escalated` (depends on state)

---

### 3. responders

Tracks responders who are responding to a dispatch. Junction table (dispatch â†” users).

```sql
CREATE TABLE responders (
  id VARCHAR(32) PRIMARY KEY,          -- Format: "resp_<uuid>"
  dispatch_id VARCHAR(32) NOT NULL,    -- FK: dispatches.id
  responder_id VARCHAR(32) NOT NULL,   -- FK: users.id
  region_id VARCHAR(32) NOT NULL,      -- Denormalized for queries
  
  -- Status tracking
  status ENUM(
    'responding', 
    'arrived', 
    'assisting', 
    'cleared'
  ) NOT NULL DEFAULT 'responding',
  
  -- Timestamps
  claimed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  FOREIGN KEY (dispatch_id) REFERENCES dispatches(id) ON DELETE CASCADE,
  FOREIGN KEY (responder_id) REFERENCES users(id) ON DELETE RESTRICT,
  
  PRIMARY KEY (id),
  UNIQUE KEY unique_responder_per_dispatch (dispatch_id, responder_id),
  INDEX idx_dispatch (dispatch_id),
  INDEX idx_responder (responder_id),
  INDEX idx_region (region_id),
  INDEX idx_claimed_at (claimed_at)
);
```

**Fields:**

| Field | Type | Nullable | Rules | Example |
|-------|------|----------|-------|---------|
| `id` | VARCHAR(32) | âŒ | PK; format "resp_(uuid)" | "resp_123" |
| `dispatch_id` | VARCHAR(32) | âŒ | FK: dispatches.id | "dsp_abc123" |
| `responder_id` | VARCHAR(32) | âŒ | FK: users.id | "usr_xyz789" |
| `region_id` | VARCHAR(32) | âŒ | Denormalized from dispatch | "us-east-1" |
| `status` | ENUM | âŒ | One of: responding, arrived, assisting, cleared | "arrived" |
| `claimed_at` | TIMESTAMP | âŒ | UTC; when responded | "2026-01-17T14:35:00Z" |
| `updated_at` | TIMESTAMP | âŒ | UTC; auto-updated | "2026-01-17T14:40:00Z" |

**Responder Status Transitions:**

```
responding â”€â”€â†’ arrived â”€â”€â†’ assisting â”€â”€â†’ cleared
```

All transitions forward-only; backward transitions logged as anomalies but allowed.

---

### 4. audit_log

Immutable, append-only event log. Records all mutations to dispatches and responders.

```sql
CREATE TABLE audit_log (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  dispatch_id VARCHAR(32) NOT NULL,    -- FK: dispatches.id
  responder_entry_id VARCHAR(32),      -- FK: responders.id (nullable)
  region_id VARCHAR(32) NOT NULL,      -- Denormalized for queries
  
  -- Event details
  event_type ENUM(
    'dispatch_created',
    'dispatch_updated',
    'dispatch_closed',
    'dispatch_reopened',
    'dispatch_escalated',
    'responder_joined',
    'responder_status_updated',
    'location_updated',
    'urgency_updated',
    'description_updated'
  ) NOT NULL,
  
  actor_id VARCHAR(32),                -- FK: users.id (nullable for system events)
  before_state JSON,                   -- Snapshot of data before change
  after_state JSON,                    -- Snapshot of data after change
  changed_fields JSON,                 -- Array of field names that changed
  
  -- Timestamps (immutable)
  timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  
  FOREIGN KEY (dispatch_id) REFERENCES dispatches(id) ON DELETE CASCADE,
  FOREIGN KEY (responder_entry_id) REFERENCES responders(id) ON DELETE SET NULL,
  FOREIGN KEY (actor_id) REFERENCES users(id) ON DELETE SET NULL,
  
  INDEX idx_dispatch (dispatch_id),
  INDEX idx_region (region_id),
  INDEX idx_timestamp (timestamp),
  INDEX idx_event_type (event_type),
  INDEX idx_actor (actor_id),
  INDEX idx_dispatch_timestamp (dispatch_id, timestamp DESC)
);
```

**Fields:**

| Field | Type | Nullable | Rules | Example |
|-------|------|----------|-------|---------|
| `id` | BIGINT | âŒ | Auto-increment PK | 12345 |
| `dispatch_id` | VARCHAR(32) | âŒ | FK: dispatches.id | "dsp_abc123" |
| `responder_entry_id` | VARCHAR(32) |  | FK: responders.id | "resp_123" |
| `region_id` | VARCHAR(32) | âŒ | Denormalized | "us-east-1" |
| `event_type` | ENUM | âŒ | One of: dispatch_created, dispatch_updated, etc. | "responder_joined" |
| `actor_id` | VARCHAR(32) |  | FK: users.id (null for system events) | "usr_xyz789" |
| `before_state` | JSON |  | Snapshot before mutation | `{"status":"open","urgency":"normal"}` |
| `after_state` | JSON |  | Snapshot after mutation | `{"status":"acknowledged","urgency":"normal"}` |
| `changed_fields` | JSON |  | Array of field names | `["status"]` |
| `timestamp` | TIMESTAMP | âŒ | UTC; immutable | "2026-01-17T14:35:00Z" |

**Example Audit Trail:**

```
Event 1: dispatch_created
  before_state: null
  after_state: {id: "dsp_abc123", status: "open", urgency: "critical", submitter_id: "usr_abc123"}
  actor_id: "usr_abc123"

Event 2: responder_joined
  before_state: null
  after_state: {id: "resp_123", responder_id: "usr_xyz789", status: "responding"}
  actor_id: "usr_xyz789"

Event 3: dispatch_updated
  before_state: {status: "open", urgency: "critical"}
  after_state: {status: "acknowledged", urgency: "critical"}
  actor_id: null (system auto-update)
  changed_fields: ["status"]

Event 4: responder_status_updated
  before_state: {status: "responding"}
  after_state: {status: "arrived"}
  actor_id: "usr_xyz789"

Event 5: dispatch_closed
  before_state: {status: "acknowledged"}
  after_state: {status: "closed", closure_reason: "turned_out_okay"}
  actor_id: "usr_xyz789"
```

---

### 5. notification_queue (Optional, for Event Delivery)

Temporary queue for SSE event delivery. Can be implemented as in-memory cache (Redis) or database table.

```sql
CREATE TABLE notification_queue (
  id BIGINT AUTO_INCREMENT PRIMARY KEY,
  dispatch_id VARCHAR(32) NOT NULL,
  event_type VARCHAR(50) NOT NULL,
  payload JSON NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  delivered_at TIMESTAMP,
  
  INDEX idx_dispatch (dispatch_id),
  INDEX idx_created_at (created_at),
  INDEX idx_delivered_at (delivered_at)
);
```

**Alternative (Redis):** For MVP, use Redis list per region:
- Key: `notifications:us-east-1`
- Value: JSON event objects
- TTL: 24 hours

---

## Data Validation Rules

### Location Validation

```
latitude: -90 â‰¤ value â‰¤ 90
longitude: -180 â‰¤ value â‰¤ 180
precision: must be one of (exact, block, neighborhood, city)

Precision semantics:
  - exact: GPS coordinate, precision to ~1m
  - block: City block level, precision to ~100m
  - neighborhood: Neighborhood level, precision to ~1km
  - city: City level, precision to ~10km
```

### Urgency Validation

```
urgency: must be one of (low, normal, critical)

Semantics:
  - low: Feed-only, no push notification
  - normal: Silent push notification (badge only)
  - critical: Immediate push notification (sound + vibration)

Auto-downgrade rule:
  - After 2 hours without update, auto-downgrade: critical â†’ normal â†’ low
  - Downgrade is logged as system event
```

### Status Validation

```
Valid transitions:
  open â†’ acknowledged (manual or auto on first responder)
  acknowledged â†’ escalated (auto after 10 min no response)
  acknowledged â†’ closed (manual by any responder)
  escalated â†’ closed (manual by any responder)
  closed â†’ reopened (manual within 15 min of closure by original submitter)
  reopened â†’ acknowledged (on reopen)

Invalid transitions: (reject with 409 Conflict)
  closed â†’ open (must go through reopened)
  escalated â†’ acknowledged (no downgrade)
```

### Description Validation

```
Max length: 2000 characters
Required: No (can be empty string)
Format: Plain text, no HTML/Markdown
Forbidden patterns: (checked by content filter)
  - Phone numbers (for privacy)
  - Email addresses (for privacy)
  - Offensive language (flagged for review)
```

---

## Indexing Strategy

### Query Patterns & Indexes

**Most Common Query: List active dispatches in region**
```sql
SELECT * FROM dispatches
WHERE region_id = 'us-east-1'
  AND status IN ('open', 'acknowledged', 'escalated')
  AND is_deleted = FALSE
ORDER BY created_at DESC
LIMIT 50;

Index: idx_region_status (region_id, status) or compound index (region_id, status, created_at DESC)
```

**Pagination: Cursor-based listing**
```sql
SELECT * FROM dispatches
WHERE region_id = 'us-east-1'
  AND created_at < <cursor_timestamp>
  AND is_deleted = FALSE
ORDER BY created_at DESC
LIMIT 50;

Index: idx_region_created (region_id, created_at DESC)
```

**Responders for dispatch**
```sql
SELECT * FROM responders
WHERE dispatch_id = 'dsp_abc123'
ORDER BY claimed_at DESC;

Index: idx_dispatch (dispatch_id)
```

**Audit trail for dispatch**
```sql
SELECT * FROM audit_log
WHERE dispatch_id = 'dsp_abc123'
ORDER BY timestamp DESC;

Index: idx_dispatch_timestamp (dispatch_id, timestamp DESC)
```

### Index Summary

| Table | Indexes | Purpose |
|-------|---------|---------|
| `users` | idx_email, idx_role, idx_is_active, idx_created_at | Login, role filtering, active user listing |
| `dispatches` | idx_region_status, idx_region_created, idx_submitter, idx_created_at, idx_urgency | Active dispatch listing, pagination, filtering |
| `responders` | idx_dispatch, idx_responder, idx_claimed_at | Responder lookup, status tracking |
| `audit_log` | idx_dispatch_timestamp, idx_region, idx_event_type, idx_actor | Audit trail queries, event filtering |

---

## Conflict Resolution & Offline Sync

### Optimistic Versioning (Conflict Detection)

Every dispatch has a `version` field (int, starts at 1). On update, client must include version:

```sql
UPDATE dispatches
SET urgency = 'low', version = version + 1, updated_at = NOW()
WHERE id = 'dsp_abc123' AND version = 2
  AND region_id = 'us-east-1';

-- If version mismatch, UPDATE returns 0 rows affected
-- Client should retry with current version from SELECT
```

### Offline Sync (Sprint 5, if in MVP)

**Decision: Last-Write-Wins (simple, suitable for MVP)**

When syncing offline-submitted dispatch:

```sql
INSERT INTO dispatches (id, client_id, region_id, submitter_id, ...)
VALUES ('dsp_new_1', 'queue_1', 'us-east-1', 'usr_abc123', ...)
ON DUPLICATE KEY UPDATE
  client_id = VALUES(client_id),
  version = 1,
  created_at = GREATEST(created_at, VALUES(created_at));
  -- If same client_id already exists, don't duplicate
```

**Conflict on Location Update (offline edit + online edit)**

```
Offline:  User moves location from A â†’ B (no internet)
Online:   Another responder updates location from A â†’ C

Sync:     Client sends B with version=1
          Server has version=2 (from C)
          409 Conflict returned
          Client re-fetches, gets C, must decide to:
            - Accept C (other responder's location)
            - Override with B (own edit)
            - Merge to average location
```

For MVP, recommend: **Let user choose** (show both options in UI).

---

## Soft Deletes & Data Retention

### Soft Delete Pattern

Instead of hard DELETE, set `is_deleted = TRUE`:

```sql
UPDATE dispatches SET is_deleted = TRUE
WHERE id = 'dsp_abc123';

-- Query does not include soft-deleted records:
SELECT * FROM dispatches
WHERE region_id = 'us-east-1'
  AND is_deleted = FALSE;
```

**Audit trail preserved:** Soft-deleted records remain in `audit_log` forever.

### Data Retention Policy

| Table | Retention | Notes |
|-------|-----------|-------|
| `dispatches` | 2 years | Soft delete after resolution; purge after 2 years |
| `responders` | 2 years | Cascade delete with dispatch |
| `audit_log` | Unlimited | Immutable; keep forever for compliance |
| `users` | Active users only | Soft delete on user removal; archive after 1 year |

---

## Migration Strategy

### Phase 1: Initial Schema (Sprint 0)

```sql
-- Sprint 0, Phase A
CREATE TABLE users;
CREATE TABLE dispatches;

-- Sprint 0, Phase B
CREATE TABLE responders;
CREATE TABLE audit_log;
```

### Phase 2: Indexes (Sprint 0, Phase B)

Add indexes after table creation; build offline to avoid locking:

```sql
ALTER TABLE dispatches
ADD INDEX idx_region_status (region_id, status),
ADD INDEX idx_region_created (region_id, created_at DESC);
```

### Phase 3: Constraints (Sprint 1)

Add foreign keys after data model is stable:

```sql
ALTER TABLE dispatches
ADD CONSTRAINT fk_submitter FOREIGN KEY (submitter_id) REFERENCES users(id);
```

### Deployment Checklist

- [ ] Backup production database before migration
- [ ] Test migration on staging environment
- [ ] Create schema in production (blue-green deployment)
- [ ] Verify all indexes created and healthy
- [ ] Verify FK constraints not blocking reads/writes
- [ ] Monitor query performance post-migration
- [ ] Run regression tests on all API endpoints
- [ ] Verify audit_log has entries for sample operations
- [ ] Health check: SELECT 1 FROM users; (should work immediately)

---

## Performance Tuning

### Query Performance Targets

| Query | Target | Strategy |
|-------|--------|----------|
| List active dispatches (with 50K records) | < 100ms | Compound index (region, status, created_at) |
| Get dispatch detail (by ID) | < 10ms | PK index (automatic) |
| List responders for dispatch | < 20ms | FK index (idx_dispatch) |
| Insert dispatch | < 50ms | No big indexes on insert path |
| Update urgency | < 50ms | Version check, not scan |

### Sharding Strategy (Post-MVP)

For millions of dispatches, consider sharding by region:

```
Shard 1: us-east-1, us-east-2
Shard 2: us-west-1, us-west-2
Shard 3: eu-west-1, eu-central-1
```

All queries include `region_id`, enabling efficient routing.

---

## Testing Checklist

**Before Sprint 0 Completes:**

- [ ] Users table: INSERT, SELECT, UPDATE, DELETE (soft)
- [ ] Dispatches table: INSERT with valid location, SELECT by region, UPDATE with version check
- [ ] Responders table: INSERT (junction), CASCADE delete, UNIQUE constraint on (dispatch, responder)
- [ ] Audit log: INSERT immutable records, SELECT with filters, retention policy enforced
- [ ] FK constraints: Enforce referential integrity (no orphaned records)
- [ ] Versioning: Increment on UPDATE, conflict detection on mismatch
- [ ] Soft delete: Records excluded from normal queries, preserved in audit_log
- [ ] Pagination: Cursor works across multiple requests, no duplicates
- [ ] Indexes: Query performance within targets, explain plan verified
- [ ] Region filtering: Queries respect region_id, no data leakage across regions
- [ ] Concurrency: Multiple updates to same dispatch don't corrupt data

---

## Deployment Requirements

### Database System

- **RDBMS:** MySQL 8.0+ or PostgreSQL 13+
- **Storage:** SSD for low-latency indexing
- **Memory:** Sufficient buffer pool for working set (90% of dispatches table)
- **Backup:** Automated daily snapshots, retention 30 days
- **Replication:** Primary + replica for read scaling and HA

### Connection Pooling

- **Min Connections:** 10
- **Max Connections:** 100
- **Timeout:** 5 seconds
- **Idle Timeout:** 10 minutes

---

## Related Documents

- [Backend API Contracts](/specs/backend-api-contracts) - API endpoints that query this schema
- [MVP Gaps & Blockers](/roadmap/mvp-gaps-and-blockers#2-database-schema--persistence-not-documented) - Blocker #2 (this document)
- [System Constitution](/constitution/system-constitution) - Design principles
- [Invariant Checklist](/compliance/invariant-checklist) - Compliance verification

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2026-01-17 | Initial MVP schema covering all entities required for Sprints 0-4 |

---

## Owners & Contacts

| Role | Name/Team | Deadline |
|------|-----------|----------|
| Database Design Owner | Backend/DB Lead | (TBD) |
| Schema Migration Owner | DevOps Lead | (TBD) |
| Performance Tuning | Database Architect | (TBD) |
| Audit Trail Implementation | Backend Lead | (TBD) |

---

**Document Status:** ğŸŸ¢ **READY FOR IMPLEMENTATION**  
**Unblocks:** Sprints 0, 1, 2, 3, 4  
**Depends On:** [Backend API Contracts](/specs/backend-api-contracts) (Blocker #1)  
**Blocks:** [Authentication Architecture](/roadmap/mvp-gaps-and-blockers#3-authentication--authorization-architecture-not-defined) (Blocker #3, design partner)

---

## Next Steps

1. **Database team:** Review schema and create migration scripts by 2026-01-20
2. **Backend team:** Integrate migrations into CI/CD pipeline
3. **DevOps team:** Set up staging database environment
4. **QA team:** Prepare data validation tests (see Testing Checklist)
5. **All teams:** Validate schema aligns with [Backend API Contracts](/specs/backend-api-contracts) (Blocker #1)
